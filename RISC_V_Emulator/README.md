# RISC-V Cache Emulator

Учебный эмулятор 32-битного RISC-V процессора с кэшем L1 и сравнением двух политик замещения: **LRU** и **bpLRU**

---

## Что делает этот проект

Проект представляет собой небольшой эмулятор 32-битного процессора RISC-V с базовой памятью и моделью кэша L1. Он позволяет запускать бинарную программу, наблюдать её выполнение и сравнивать эффективность двух политик замещения кэша.

### Возможности процессора

- Эмулирует работу 32-битного RISC-V:  
  - регистры `x0..x31` (где `x0` всегда равен 0),  
  - 32-битный счётчик команд `pc`,  
  - инструкции наборов **RV32I** и **RV32M**: арифметика, логика, ветвления, загрузки/сохранения, умножение и деление.
- Работает в линейном адресном пространстве объёмом **512 KiB**.

### Модель кэша L1

Эмулятор использует программную модель унифицированного (общего для инструкций и данных) кэша L1 и считает статистику попаданий.

#### Параметры кэша

- объём: **2 KiB**  
- размер строки: **32 байта**  
- ассоциативность: **4-way set-associative**  
- политика записи: **write-back + write-allocate**  
- архитектура: фон-неймановская (единое пространство кода и данных)

#### Политики замещения

- **LRU** — классическая least recently used  
- **bpLRU** — простая bit-pseudo-LRU

Для каждой политики собирается статистика:
- общий hit rate  
- hit rate для инструкций  
- hit rate для данных

### Вывод и сохранение результатов

- Программа выводит таблицу со статистикой по кэшу.  
- При запросе может сохранить итоговое состояние регистров и выбранный диапазон памяти в бинарный файл.


---

## Сборка

### Вариант 1: через CMake

```bash
mkdir build
cd build
cmake ..
cmake --build .
```
### Вариант 2: напрямую через g++

```bash
g++ main.cpp -o RISC-V
```


---

## Запуск

### 1. Выполнить программу и вывести статистику кэша

```bash
./RISC-V -i ../task.bin
```

- загружается начальное состояние из `task.bin`,
- программа выполняется:
  - сначала с политикой `bpLRU`,
  - затем с политикой `LRU`,
- в `stdout` печатается сравнительная статистика.

### 2. Выполнить программу и сохранить результат

```bash
./RISC-V -i ../task.bin -o ../result.bin 0x1000 256
```

Где:
- `result.bin` — выходной бинарный файл,
- `0x1000` — начальный адрес интересующего диапазона памяти (hex),
- `256` — размер диапазона в байтах.

В файл попадут финальный `pc`, финальные значения регистров и срез памяти по указанному адресу.

---

## Пример вывода

Пример того, что печатает эмулятор после выполнения task.bin (файл написан мной на ассемблере, задача была получить процент попадания для инструкций = 93.5%, для данных = 62.5%):

```text
replacement     hit rate        hit rate (inst) hit rate (data)
        LRU     79.86111%       93.75000%       62.50000%      
      bpLRU     79.86111%       93.75000%       62.50000% 
```

---

## ТЗ:

### Цель

Разработать консольное приложение на C++, которое:

- эмулирует выполнение простой 32-битной RISC-V программы в фон-неймановской архитектуре с ОЗУ 512 KiB,
- моделирует L1-кэш с двумя политиками замещения (LRU и bpLRU),
- собирает и сравнивает hit-rate для инструкций и данных,
- по запросу сохраняет итоговое состояние процессора и фрагмент памяти.

Также необходимо предоставить task.bin, при выполнении которого процент попадания в кэш (для обеих политик вытеснения) для инструкций будет равен 93.75%, для данных равен 62.5%

---

### Основная функциональность

1. **Эмулятор процессора**
   - 32-битный RISC-V:
     - 32 регистра общего назначения `x0..x31`, `x0` всегда равен 0,
     - 32-битный `pc`.
   - Должны поддерживаться все инструкции RV32I/RV32M

2. **Память**
   - Линейное адресное пространство размером **512 KiB**, адресуемое по байтам.
   - Начальное состояние памяти задаётся фрагментами из входного файла: (адрес, размер, данные).

3. **Кэш L1**
   - Объем: **2 KiB**.
   - Организация:
     - размер строки: 32 байта,
     - 4-way set-associative,
     - единый кэш для инструкций и данных,
     - write-back + write-allocate.
   - Политика замещения:
     - **LRU**
     - **bpLRU**
   - Статистика отдельно для:
     - всех обращений,
     - обращений к инструкциям,
     - обращений к данным.

4. **Статистика**
   - Для каждой политики:
     - общее число обращений к кэшу и число попаданий,
     - число обращений/попаданий для инструкций,
     - число обращений/попаданий для данных.
   - Выводится таблица с колонками:
     - `replacement`,
     - `hit rate`,
     - `hit rate (inst)`,
     - `hit rate (data)`.

---

### Интерфейс командной строки

Поддерживаются аргументы:

- `-i <input_file>`  
  Входной бинарный файл с начальными значениями регистров и памяти (обязательный параметр).

- `-o <output_file> <hex_addr> <size>`  
  Опциональная запись результата:
  - `output_file` — имя выходного файла,
  - `hex_addr` — начальный адрес диапазона памяти в шестнадцатеричном виде (например, `0x1000`),
  - `size` — длина диапазона в байтах (десятичное число).

Без `-o` программа просто выполняет код и печатает статистику кэша.

---

### Формат входного файла

Входной файл (`-i`) — бинарный, little-endian:

1. `uint32_t pc` — начальный счётчик команд.
2. 31 × `uint32_t` — начальные значения регистров `x1..x31`.
3. Далее до конца файла — фрагменты памяти, каждый:
   - `uint32_t addr` — базовый адрес фрагмента,
   - `uint32_t size` — размер фрагмента в байтах,
   - `size` байт — собственно данные, которые нужно положить по адресу `addr`.

Регистру `x0` внутри эмулятора всегда принудительно ставится 0.

---

### Формат выходного файла

Выходной файл (`-o`) — бинарный, little-endian:

1. `uint32_t pc` — финальное значение счётчика команд.
2. 31 × `uint32_t` — финальные значения регистров `x1..x31`.
3. `uint32_t output_addr` — адрес начала выбранного диапазона.
4. `uint32_t output_size` — длина диапазона.
5. `output_size` байт — содержимое памяти по адресу `output_addr`.

---

### Дополнительные требования

- Язык: C++17 или новее.
- Основные параметры кэша (размер, строка, ассоциативность) задаются через константы в исходнике, чтобы их можно было легко менять.
- Эмулятор должен корректно обрабатывать:
  - выход за границы памяти (не UB),
  - записи грязных линий обратно в память,
  - знаковое/беззнаковое расширение при загрузках.
- Код должен быть детерминированным — одно и то же входное состояние всегда даёт одинаковый результат.
