# IEEE 754 Floating-Point

Небольшая консольная утилита для работы с числами с плавающей точкой по стандарту **IEEE 754**.

Поддерживаются два формата:

- **binary32** (single precision, 32 бита),
- **binary16** (half precision, 16 бит),

и операции:

- `+`, `-`, `*`, `/`,
- `fma` — fused multiply-add (a * b + c с одним этапом округления),
- `mad` — обычное multiply-add (a * b, затем + c с отдельным округлением).

Также реализованы разлиыне режимы округления (по стандарту IEEE 754), корректно обрабатываются NaN/Inf/денормалы/±0, результат выводится в двух видах: нормализованный hex-float и исходный hex-формат



## Сборка

### Вариант 1: через g++

```bash
g++ -o FloatPoint main.cpp
```

### Вариант 2: через CMake

```bash
mkdir build
cd build
cmake ..
cmake --build .
```

---

## Примеры запуска

### 1. Форматирование одного числа
```bash
./FloatPoint h 1 3C00
./FloatPoint s 1 3F800000
```

### 2. Бинарные операции
```bash
./FloatPoint h 1 + 3C00 4000
./FloatPoint s 0 * 3F800000 40000000
./FloatPoint s 3 / 7F800000 3F800000
```

### 3. FMA (a * b + c с одним округлением)
```bash
./FloatPoint s 1 fma 3F800000 40000000 3F800000
```

### 4. MAD (a * b, затем + c с отдельным округлением)
```bash
./FloatPoint s 2 mad 3F800000 40000000 3F800000
```

---

## ТЗ:

### 1. Задача

Реализовать консольную утилиту на C++, которая:

- выполняет арифметику с плавающей точкой по стандарту **IEEE 754** для форматов **binary16** и **binary32**,
- поддерживает операции `+`, `-`, `*`, `/`, `fma` и `mad`,
- работает с четырьмя режимами округления IEEE 754,
- принимает числа в виде hex-битового представления и выводит результат в hex-float и hex.

---

### 2. Форматы и представление

Поддерживаемые форматы:

- **binary32 (float, 32 бита)**  
  - 1 бит знака, 8 бит экспоненты (bias 127), 23 бита мантиссы.
- **binary16 (half, 16 бит)**  
  - 1 бит знака, 5 бит экспоненты (bias 15), 10 бит мантиссы.

Требуется корректная реализация по IEEE 754:

- нормализованные числа,
- денормализованные (subnormal),
- ±0,
- ±∞,
- NaN (quiet NaN и signal NaN).

Запрещено пользоваться стандартными `float`/`double`: вся логика должна работать по битовым полям (sign/exp/mantissa).

---

### 3. Режимы округления

Режим задаётся вторым аргументом командной строки (целое число `0..3`):

- `0` — округление к нулю,
- `1` — round to nearest, ties-to-even (стандартный режим IEEE 754),
- `2` — округление к +∞,
- `3` — округление к -∞.

Округление применяется ко всем операциям: `+`, `-`, `*`, `/`, `fma`, `mad`.

---

### 4. Интерфейс командной строки

Общий формат запуска:

```bash
program <precision> <rounding> [op] <arg1> [arg2] [arg3]
```

Где:

- `<precision>`:
  - `h` → формат **binary16** (half precision),
  - иначе → формат **binary32** (single precision).
- `<rounding>` — режим округления (`0..3`).
- `<argN>` — входные числа

Поддерживаются три режима по числу аргументов:

#### 4.1. Один аргумент (форматирование)

```bash
program h 1 3C00
program s 1 3F800000
```

- Выводится значение числа в hex-float формате и его hex-паттерн.

#### 4.2. Два аргумента (бинарная операция)

```bash
program h 1 + 3C00 4000
program s 0 * 3F800000 40000000
program s 3 / 7F800000 3F800000
```

- Третий параметр — операция: `+`, `-`, `*`, `/`.
- Числа читаются как hex, интерпретируются как binary16/binary32.
- Обрабатываются NaN/Inf/0 по правилам IEEE 754.
- Результат округляется и печатается.

#### 4.3. Три аргумента (FMA и mad)

```bash
program s 1 fma 3F800000 40000000 3F800000   # a * b + c, один этап округления
program s 2 mad 3F800000 40000000 3F800000   # a * b, затем + c с отдельным округлением
```

- Если `op == "fma"` → режим **fused multiply-add**:
  - выполняется a * b + c с **одним** этапом округления в конце.
- Если `op == "mad"` → режим **обычного multiply-add**:
  - сначала выполняется `a * b` с округлением,
  - затем результат складывается с `c` с ещё одним этапом округления,
  - дополнительно обрабатываются спец. случаи вроде Inf ± Inf, 0 * Inf и т.п.

При некорректном числе аргументов или ошибке парсинга программа должна завершить работу с кодом `1`.

---

### 5. Специальные случаи IEEE 754

Утилита должна следовать базовым правилам IEEE 754:

- любая операция с NaN возвращает NaN (на печать идёт соответствующее значение),
- комбинации вроде:
  - `0 * Inf`, `Inf * 0`,
  - `Inf / Inf`, `0 / 0`,
  - `Inf - Inf`,
  - `Inf + (-Inf)`
  - `и т.п. (смотри документацию IEEE 754)`

  дают NaN,
- при переполнении экспоненты результат — либо максимально представимое конечное число, либо ±∞ (в зависимости от знака и режима округления),
- при сильном недополнении результат — денормализованное число или ±0,
- знак нуля сохраняется (различаем +0 и -0).

---

### 6. Формат вывода

Для каждого числа выводятся две части:

1. Нормализованный hex-float:

   - для binary32: `[-]0x1.XXXXXXp±E`,
   - для binary16: `[-]0x1.XXXp±E`.

2. Битовое представление в hex:

   - для binary32: `0xXXXXXXXX`,
   - для binary16: `0xXXXX`.

Для специальных значений:

- `nan` / `inf` / `-inf`,
- для ±0 — `0x0.000...p+0` / `-0x0.000...p+0` (в зависимости от формата и знака).

---

### 7. Требования к реализации

- Язык: **C++17** или новее.
- Основные вычисления — через целочисленные операции над полями (sign, exponent, mantissa), без использования встроенных `float`/`double`
- Никаких внешних библиотек, только стандартная библиотека C++.
- При ошибке входных данных программа возвращает код `1`, при успешном выполнении — `0`.
