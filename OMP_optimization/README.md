# Image Contrast Optimization

Этот проект реализует обработку изображений в форматах **PNM (P5/P6)** — корректировку яркости и контрастности с опциональным использованием **OpenMP**.  
Цель — растянуть диапазон значений яркости, сохранив оттенки и структуру изображения, а также обеспечить максимально возможное ускорение за счёт параллельных вычислений.

---

## Сборка и запуск

### 1. Сборка через CMake

```bash
mkdir build
cd build
cmake ..
cmake --build .
```

### 2. Примеры запуска

Обработка изображения с коэффициентом 0.02:

```bash
./OptimizationLab --input in.pnm --output out.pnm --coef 0.02
```

Запуск с OpenMP, 8 потоков и динамическим планированием:

```bash
./OptimizationLab --input test_data/in.pnm --output out.pnm --coef 0.01 --omp-threads 8 --schedule dynamic --chunk_size 4096
```

Запуск с планировщиком static:

```bash
./OptimizationLab --input test_data/in.pnm --output out_static.pnm --coef 0.003 --schedule static --chunk_size 2048
```

Отключение OpenMP (полностью однопоточный режим):

```bash
./OptimizationLab --input test_data/in.pnm --output out_single.pnm --coef 0.004 --no-omp
```

Потоки по умолчанию и автоматический выбор их количества:

```bash
./OptimizationLab --input test_data/in.pnm --output out_auto.pnm --coef 0.005
```


## Использованные конструкции OpenMP

```#pragma omp parallel``` - создает несколько потоков и выполняет код внутри на каждом из этих потоков

```#pragma omp for schedule(runtime)``` - делит цикл for по потокам по потокам согласно параметрам, которые мы указали в ```omp_set_schedule(...)```

```omp_set_schedule(...)``` - задает размер чанка, а также тип планирования (static - итерации цикла разбиваются по размеру чанка и распределяются по потокам перед началом испольнения кода, dynamic - итерации цикла также разбиваются по размеру чанка, но распределяются по потокам в момент завершения потоком обработки предыдущего блока)

```#pragma omp critical``` - выполняет код внутри по очереди для каждого из потоков

```omp_set_num_threads(...)``` - задает число потоков


```omp_get_num_procs()``` - возвращает число логических ядер системы

```omp_get_wtime()``` - возвращает текущее время (система отсчета не важна, мы берем разницу двух времен)



## Описание алгоритма

Задача программы — выполнить контрастную обработку изображений в форматах PGM/PPM:

1. посчитать гистограммы яркостей (для PGM) или по каналам RGB (для PPM),
2. по гистограмме определить «граничные» значения яркости (низ и верх), игнорируя заданный процент самых тёмных и самых светлых пикселей,
3. построить таблицу отображения «старый пиксель → новый пиксель»,
4. применить эту таблицу ко всему изображению (растянуть контраст).

Для ускорения используются разные участки кода с OpenMP — там, где много независимых однотипных операций.

### 1) Создание гистограмм

**Без OpenMP (PGM):**

- Однократный проход по массиву пикселей.
- Для каждого пикселя просто увеличивается соответствующий элемент массива `histogram[0..255]`.

**Без OpenMP (PPM):**

- Массив данных содержит тройки байт (R, G, B).
- В каждом шаге цикла обрабатываются по три байта:
  - инкрементируется `r_histogram[значение R]`,
  - `g_histogram[значение G]`,
  - `b_histogram[значение B]`.

**С OpenMP (PGM):**

- В параллельной области каждый поток создаёт свою локальную гистограмму `small_histogram[256]`, инициализируя её нулями.
- Цикл прохода по пикселям размечается через `#pragma omp for schedule(runtime)`:
  - каждый поток считает только свой кусок данных в локальный массив.
- После окончания цикла все локальные гистограммы объединяются в одну общую в секции `#pragma omp critical`:
  - для каждого значения яркости `i` суммируются `small_histogram[i]` из всех потоков.

**С OpenMP (PPM):**

- Аналогичная схема, но локальные массивы создаются для каждого канала: `small_r_histogram`, `small_g_histogram`, `small_b_histogram`.
- В параллельном цикле каждый поток обновляет только свои локальные массивы.
- В критической секции локальные гистограммы по всем потокам складываются в общие `r_histogram`, `g_histogram`, `b_histogram`.

В итоге самый тяжёлый по количеству операций этап (проход по пикселям) оказывается эффективно распараллелен.

### 2) Поиск граничных пикселей

На этом шаге по гистограмме определяется диапазон яркостей `[low, high]`, внутри которого находится «основной» массив пикселей, а края (самые тёмные и самые светлые `coef` процентов) отбрасываются.

Для PGM:

- Считается префиксная сумма `lower_sum` от 0 до 255, пока сумма не превысит число игнорируемых пикселей — найден `low`.
- Аналогично с конца (от 255 к 0) набирается `upper_sum`, пока сумма не превысит порог — найден `high`.

Общее количество обрабатываемых значений здесь всего 256, поэтому распараллеливать этот участок нет смысла.

Для PPM:

- По тому же принципу находятся границы отдельно для R, G и B.
- Итоговые границы для всей картинки берутся как:
  - `low = min(low_R, low_G, low_B)`,
  - `high = max(high_R, high_G, high_B)`.

### 3) Построение таблицы соответствия и применение к исходной картинке

Создаётся массив `mapping_table[256]`, который задаёт преобразование `старый_пиксель -> новый_пиксель`, чтобы не считать заново новое значение для каждого пикселя картинки

- Для значений `<= low` всем присваивается 0 (зажимаем тёмный хвост).
- Для значений `>= high` всем присваивается 255 (зажимаем светлый хвост).
- Между `low` и `high` значения равномерно растягиваются на интервал `[0, 255]`
- с помощью таблицы создаем новое изображение, сопоставляя старому значению пикселя новое



## Тестирование

Я тестировал на ноутбуке Lenovo ThinkPad T14 Gen 2
>CPU: AMD Ryzen 7 PRO 5850U, 8C/16T, ~1.9 ГГц

>RAM: 32 ГБ

>OS: Windows 10 Pro

Тестировал на картинках ***hound0.pnm***, ***in.pnm***, ***in2.pnm***, ***225H_xc.ppm*** а также на своей аватарке с тг (размер 966*1280)

Запускал с следующими параметрами: 
* --omp-threads от 1 до 20
* --chunk_size 1, 8, 64, 256, 2048, 4096, 8192
* --schedule static/dynamic
* а также с --no-omp

Делал запуск с каждым набором параметров по 9 раз, чтобы не мешали случайо хорошие\плохие случаи. В качетсве результата брал медиану

Логи лежат в фале **logs.txt**


### Графики
Самые информативные, на мой взгляд, данные полученные с большими картинками, поэтому графиков с ними будет больше.

Также на некоторых графиках я убрал данные с маленькими чанками - время с ними получается уж очень большим и из-за этого масштаб мешает рассмотреть время с нормальными чанками 

![Сравнение времени в зависимости от чанка и количетва потоков (718x653) (static)](assets/718x653%20static.png)
![Сравнение времени в зависимости от чанка и количетва потоков (718x653) (dynamic)](assets/718x653%20dynamic.png)

---

![Сравнение времени в зависимости от чанка и количетва потоков (966x1280) (static)](assets/966x1280%20static.png)
![Сравнение времени в зависимости от чанка и количетва потоков (966x1280) (dynamic)](assets/966x1280%20dynamic.png)

---

![Сравнение времени в зависимости от чанка и количетва потоков (5760x3840) (static)](assets/5760x3840%20static.png)
![Сравнение времени в зависимости от чанка и количетва потоков (5760x3840) (dynamic)](assets/5760x3840%20dynamic.png)

---

![Сравнение без omp, лучшее с omp и 1 потоком, и самое лучшее время с omp (718x653)](assets/718x653%20no-omp.png)
![Сравнение без omp, лучшее с omp и 1 потоком, и самое лучшее время с omp (966x1280)](assets/966x1280%20no-omp.png)
![Сравнение без omp, лучшее с omp и 1 потоком, и самое лучшее время с omp (5760x3840)](assets/5760x3840%20no-omp.png)

---

![Сравнение лучшего времени в зависимости от чанка и выбора типа планирования (966x1280)](assets/best%20time%20966x1280.png)
![Сравнение лучшего времени в зависимости от чанка и выбора типа планирования (5760x3840)](assets/best%20time%205760x3840.png)

---

![Сравнение static и dynamic на большой картинке (5760x3840) с выбранным чанком 4096](assets/5760x3840%20chunk%204096.png)

---

![Сравнение спидапов, в зависимости от колличества потоков и типа планирования, с выбранным чанком 4096 (718x653)](assets/speedup%20718x653.png)
![Сравнение спидапов, в зависимости от колличества потоков и типа планирования, с выбранным чанком 4096 (966x1280)](assets/speedup%20966x1280.png)
![Сравнение спидапов, в зависимости от колличества потоков и типа планирования, с выбранным чанком 4096 (5760x3840)](assets/speedup%205760x3840.png)



### Анализ графиков
* На небольших картинках спидап по сравнению с версией без omp не очень большой, из-за того что накладные расходы на создание, синхронизацию потоков сопоставимы с общей работой

* Также на небольших картинках чаще лучше себя показывают небольшое количество потоков (так как при росте числа потоков накладные расходы съедают выйгрыш) - поэтому при запуске с ```--omp-threads default``` я [выбираю](https://github.com/skkv-se-comp-arch/ca25-optimizations-maksimbelov1/blob/main/main.cpp#L312-L320) колличетво потоков в зависимости от размера изображения 

* Еще на небольших картинках static ведет себя стабильнее (больше чанков ведут себя адекватно, что не скажешь о dynamic, где, например, при небольших чанках (1, 8, 64) программа может работать даже медленнее версии без omp) (это происходит из-за того, что на таких чанках работа dynamic планировщика сопоставима с выйгрышем от многопоточности), однако лучшие результаты (особенно это видно на больших изображениях (и с большими чанками)) я получил именно с dynamic 

## Итог 
В многопоточном режиме я получил прирост скорости до 9x по сравнению с версией без omp. Лучшие параметры у меня получились --chunk_size = 4096, --schedule = dynamic